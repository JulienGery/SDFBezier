#version 450

#define PI 3.14159265358979323846264338327950288419716939937510

#define RED 0xff0000ff
#define GREEN 0xff00ff00
#define BLUE 0xffff0000
#define WHITE 0xffffffff

struct CurveData
{
    vec4 derivatives;
    vec4 startAndEndCurve;
    vec4 previusCurveNextCurveColor;
};

layout ( push_constant) uniform constants
{
    uint maxIndex, CurvesCount, width, height;
} pushConstants;

layout (std140, binding = 0) readonly uniform UBO 
{
    CurveData curves[100];
};

layout (std140, binding = 1) readonly buffer Image
{
    vec4 SDF[ ];
    //layout: distance, inside, root, curveIndex
};

layout (std140, binding = 2) writeonly buffer OUTIMAGE
{
    uint image[ ];
};

uint CustomMix(const in uint a, const in uint b, const in float c)
{
    const uint delta = b - a;
    if(c > 1.0)
        return b;
    return a + uint(delta * c);
}

uint insideColor(const in uint a)
{
    return ~a;
}

float zCross(const vec2 a, const vec2 b)
{
    return a.x * b.y - a.y * b.x;
}

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

void main()
{ 
    uint index = gl_GlobalInvocationID.x;
    if(index < pushConstants.maxIndex)
    {
        const uint curveIndex = uint(SDF[index].w);
        const float inside = SDF[index].y;
        const float root = SDF[index].z;
        const float distanceToCurve = SDF[index].x;

        const bool isInside = inside < 0;

        uint color = uint(curves[curveIndex].previusCurveNextCurveColor.z);
        
        if(isInside)
            color = insideColor(color);

        else 
        {
            image[index] = 0;
            return;
        }

        if(distanceToCurve > 0.02 && isInside)
            color = WHITE;

        {
            const float x = index % pushConstants.width;
            const float y = (index - x) / float(pushConstants.width);
            const vec2 point = vec2((x + 0.5) / pushConstants.width, (y+0.5) / pushConstants.height);

            //TODO clean that !!
            if(root > 0.5)
            {
                const uint nextCurveIndex = uint(curves[curveIndex].previusCurveNextCurveColor.y);

                const vec2 nextCurveStartDerivate = curves[nextCurveIndex].derivatives.xy;
                const vec2 startToPoint = point - curves[nextCurveIndex].startAndEndCurve.xy;

                if(zCross(nextCurveStartDerivate, startToPoint) < 0)
                {
                    if (isInside)
                        color = WHITE;
                    else
                        color = 0;
                }
            }
            else 
            {
                const uint previusCurveIndex = uint(curves[curveIndex].previusCurveNextCurveColor.x);

                const vec2 previusCurveEndDerivate = curves[previusCurveIndex].derivatives.zw;
                const vec2 endToPoint = point - curves[previusCurveIndex].startAndEndCurve.zw;

                if(zCross(previusCurveEndDerivate, endToPoint) < 0)
                {
                    if (isInside)
                        color = WHITE;
                    else
                        color = 0;
                }
            }
            


        }

        image[index] = color | 0xff000000;
    }
}