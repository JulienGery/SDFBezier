#version 450

#define EPSILON 1e-05
#define MAXITERATION 200
#define PI 3.14159265358979323846264338327950288419716939937510

layout (binding = 0) uniform ParameterUBO {
    vec2 P_0, p1, p2, p3;
    vec4 bisector;
    int maxIndex, width, height, curveIndex;
} ubo;

layout(std140, binding = 1) readonly buffer CoefficientIn
{
    vec2 Coefficients[ ][4]; // buffer storing the coefficients of the polynomial.
};

layout(std140, binding = 2) buffer ParticleSSBOIn
{
    vec2 approximation[][3]; // buffer storing the current approximations.
};

vec2 mul(const vec2 z, const vec2 zp) // complex multiplication
{
    vec2 result;
    result.x = z.x * zp.x - z.y * zp.y;
    result.y = z.y * zp.x + z.x * zp.y;
    return result;
}

vec2 div(const vec2 z, const vec2 zp) // complex division
{
    float bottom = zp.x * zp.x + zp.y * zp.y;
    vec2 result = mul(z, vec2(zp.x, -zp.y));

    return result / bottom;
}

vec2 div(const float x, const vec2 zp)
{
    float bottom = zp.x * zp.x + zp.y * zp.y;
    return float(x) * vec2(zp.x, -zp.y) / bottom;
}

vec2 f(const vec2 z, const in vec2[4] coeff) // compute polynom at z
{
    vec2 tmp = vec2(1, 0);
    vec2 result = coeff[0];
    for(uint i = 1; i < 4; i++)
    {
        tmp = mul(tmp, z);
        result += mul(coeff[i], tmp);

    }
    return result;
}

vec2 fp(const vec2 z, const in vec2[4] coeff) // compute derivate at z.
{
    vec2 tmp = vec2(1, 0);
    vec2 result = coeff[1];
    for(uint i = 2; i < 4; i++)
    {
        tmp = mul(tmp, z);
        result += mul(coeff[i] * float(i), tmp);
    }
    return result;
}

vec2 sumOfApproximation(const uint index, const in vec2[3] values)
{
    vec2 result = vec2(0);
    for(uint j = 0; j < 3; j++)
        if (j != index)
            result += div(vec2(1, 0), values[index] - values[j]) ;
    return result;
}

float absComplex(const vec2 z)
{
    return sqrt(z.x * z.x + z.y * z.y);
}

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

vec2 complexSQRT(const float x)
{
    if(x < 0)
        return vec2(0, sqrt(abs(x)));
    return vec2(sqrt(x), 0);
}


vec2 complexEXP(const float o)
{
    return vec2(cos(o), sin(o));
}


void Aberth(const uint index)
{
    vec2 a_3 = Coefficients[index][3];
    vec2 a_0 = Coefficients[index][0];

    float offset = PI / (2.0*3.0);
    float angle = 2.0*PI/3.0;

    bool radiusZero = false;
    float radius;
    
    if(a_0.x == 0 && a_0.y == 0)
    {
        radius = pow(absComplex(div(Coefficients[index][1], a_3)), 1./2.);
        angle = 2.0*PI/2.0;
        offset = PI/(2.0 * 2.0);
        radiusZero = true;
    }
    else 
        radius = pow(absComplex(div(a_0, a_3)), 1./3.);


    for(uint i = 0; i < 3; i++)
        approximation[index][i] = radius * vec2(
            cos(i * angle + offset), sin(i * angle + offset));;

    if(radiusZero)
        approximation[index][0] = vec2(0);

    for(uint i = 0; i < MAXITERATION; i++)
    {
        const vec2[3] CurrentApproximation = approximation[index];
        uint finish = 0;
        for(uint k = 0; k < 3; k++)
        {
            const vec2 z = CurrentApproximation[k];
            const vec2 p = f(z, Coefficients[index]);
            const vec2 pp = fp(z, Coefficients[index]);

            const vec2 POverPP = div(p, pp);
            const vec2 sum = sumOfApproximation(k, CurrentApproximation);
            const vec2 zPlusOne = z - div(POverPP, vec2(1, 0) - mul(POverPP, sum));
            approximation[index][k] = zPlusOne;

            if(distance(z, zPlusOne) < EPSILON)
                finish++;
        }

        if(finish == 3)
            break;
    }
}

void main()
{
    uint index = gl_GlobalInvocationID.x;

    if(index < ubo.maxIndex)
    {
        float a = Coefficients[index][3].x;
        float b = Coefficients[index][2].x;
        float c = Coefficients[index][1].x;
        float d = Coefficients[index][0].x;

        b /= a;        
        c /= a;
        d /= a;
        a = 1;

        const float p = (3.0 * c - b * b) / 3.0;
        const float q = (9.0 * c * b - 27.0 * d - 2. * b * b * b) / 27.0;

        const float R = q / 2.0;
        const float Q = p / 3.0;

        vec2 w3 = vec2(R, 0) + complexSQRT(R * R + Q * Q * Q);
        if(abs(w3.x) < EPSILON && abs(w3.y) < EPSILON)
        {
            Aberth(index);  
            return; 
        }

        const float norm = absComplex(w3);
        const float r = pow(norm, 1.0/3.0);
        const float o = atan(float(w3.y), float(w3.x));

        for(uint i = 0; i < 3; i++)
        {
            const vec2 w = r * complexEXP((o + 2.0 * i * PI) / 3.0);
            const vec2 x = w - div(p, 3.0*w);
            approximation[index][i] = x - vec2(b / 3.0, 0);
        }
    }
}