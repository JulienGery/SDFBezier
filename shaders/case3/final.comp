#version 450

#define EPSILON 1e-5

layout (binding = 0) uniform ParameterUBO {
    vec2 P_0, p1, p2, p3;
    int maxIndex, width, height, curveIndex;
} ubo;

layout(std140, binding = 2) readonly buffer ParticleSSBOIn
{
    vec4 roots[][3];
};

layout(std140, binding = 3) buffer currentClosesetPoints
{
    vec4 result[];
    //layout: distance, inside, root, curveIndex
};

bool right(const in vec2 d, const in vec2 v)
{
    return (d.x * v.y - d.y * v.x) < 0 ? true: false;
}

vec2 Bezier(const float t)
{
    return ubo.P_0 +
    2.f * t * ubo.p1 +
    t * t * ubo.p2;
}

vec2 DBezier(const float t)
{
    return 2.f * ubo.p1 +
		    2.f * t * ubo.p2;
}

float distSquared(const vec2 A, const vec2 B )
{
    const vec2 C = A - B;
    return dot( C, C );
}

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

void main()
{
    const uint index = gl_GlobalInvocationID.x;
    if(index < ubo.maxIndex)
    {
        const float x = index % ubo.width;
        const float y = (index - x) / ubo.width;
        const vec2 point = vec2(x / ubo.width, y / ubo.height);

        for(uint i = 0; i < 3; i++)
        {
            const vec2 root = roots[index][i].xy;
            if(abs(root.y) < 1e-05)
            {
                float real = root.x;    
                real = clamp(real, 0.f, 1.f);
                const vec2 Candidate = Bezier(real);
                const float dis = distSquared(Candidate, point);
                const bool inside = right(DBezier(real), point - Candidate);

                if(dis < result[index].x)
                    result[index] = vec4(dis, inside, real, ubo.curveIndex);
                else if (inside && !bool(result[index].y) && dis == result[index].x)
                    result[index] = vec4(dis, inside, real, ubo.curveIndex);
            }
        }
    }
}