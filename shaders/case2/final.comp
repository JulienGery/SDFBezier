#version 450

#define EPSILON 1e-5

layout (binding = 0) uniform ParameterUBO {
    vec2 P_0, p1, p2, p3;
    vec4 bisector;
    int maxIndex, width, height, curveIndex;
} ubo;

layout(std140, binding = 2) readonly buffer ParticleSSBOIn
{
    vec4 roots[];
};

layout(std140, binding = 3) buffer currentClosesetPoints
{
    vec4 result[];
    //layout: distance, inside, root, curveIndex
};

vec2 Bezier(const float t)
{
    return ubo.P_0 +
            t * ubo.p1;
}

vec2 DBezier(const float t)
{
    return ubo.p1;
}

float distSquared(const vec2 A, const vec2 B )
{
    const vec2 C = A - B;
    return dot( C, C );
}

float crossZ(const vec2 d, const vec2 v)
{
    const vec2 a = normalize(d); 
    const vec2 b = normalize(v);
    return (a.x * b.y - a.y * b.x);
}

float crossN(const vec2 d, const vec2 v)
{
    return d.x * v.y - d.y * v.x;
}


layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

void main()
{
    const uint index = gl_GlobalInvocationID.x;

    if(index < ubo.maxIndex)
    {
        const float x = index % ubo.width;
        const float y = (index - x) / ubo.width;
        const vec2 point = vec2(x, y);

        if(crossN(bisector.xy, point - Bezier(0)) < 0 && crossN(bisector.zw, point - Bezier(1)) > 0)
        {
            float real = roots[index].x;
            real = clamp(real, 0.f, 1.f);
            const vec2 Candidate = Bezier(real);
            
            const float dis = distance(Candidate, point);
            const float inside = crossZ(DBezier(real), point - Candidate);

            if(dis < result[index].x)
                result[index] = vec4(dis, inside, real, ubo.curveIndex);
            else if (abs(inside) > abs(result[index].y) && dis == result[index].x)
                result[index] = vec4(dis, inside, real, ubo.curveIndex);
        }
    }
}