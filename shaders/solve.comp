#version 450

#define EPSILON 1e-05
#define MAXITERATION 200

layout (binding = 0) uniform ParameterUBO {
    vec2 P_0, p1, p2, p3;
    int maxIndex, width, height, polynomSize, curveIndex;
} ubo;

layout(std140, binding = 1) readonly buffer CoefficientIn
{
    vec2 Coefficients[ ][6]; // buffer storing the coefficients of the polynomial.
};

layout(std140, binding = 2) buffer ParticleSSBOIn
{
    volatile vec4 approximation[][5]; // buffer storing the current approximations.
};

vec2 mul(const vec2 z, const vec2 zp) // complex multiplication
{
    vec2 result;
    result.x = z.x * zp.x - z.y * zp.y;
    result.y = z.y * zp.x + z.x * zp.y;
    return result;
}

vec2 div(const vec2 z, const vec2 zp) // complex division
{
    float bottom = zp.x * zp.x + zp.y * zp.y;
    vec2 result = mul(z, vec2(zp.x, -zp.y));

    return result / bottom;
}

vec2 f(const vec2 z, const in vec2[6] coeff) // compute polynom at z
{
    vec2 tmp = vec2(1, 0);
    vec2 result = coeff[0];
    for(uint i = 1; i < ubo.polynomSize; i++)
    {
        tmp = mul(tmp, z);
        result += mul(coeff[i], tmp);

    }
    return result;
}

vec2 fp(const vec2 z, const in vec2[6] coeff) // compute derivate at z.
{
    vec2 tmp = vec2(1, 0);
    vec2 result = coeff[1];
    for(uint i = 2; i < ubo.polynomSize; i++)
    {
        tmp = mul(tmp, z);
        result += mul(coeff[i] * float(i), tmp);
    }
    return result;
}

float absComplex(const vec2 z)
{
    return sqrt(z.x * z.x + z.y * z.y);
}

vec2 sumOfApproximation(const uint index, const in vec2[5] values)
{
    vec2 result = vec2(0);
    for(uint j = 0; j < ubo.polynomSize - 1; j++)
        if (j != index)
            result += div(vec2(1, 0), values[index] - values[j]) ;
    return result;
}


vec2[5] getApproximationsCase0(const uint indexGroup)
{
    vec2[5] result;
    for(uint i = 0; i < 5; i++)
        result[i] = approximation[indexGroup][i].xy;
    return result;
}

vec2[5] getApproximationsCase1(const uint indexGroup)
{
    vec2[5] result;
    for(uint i = 0; i < 5; i++)
        result[i] = approximation[indexGroup][i].zw;
    return result;
}

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

void main()
{
    uint index = gl_GlobalInvocationID.x;
    uint subIndex = index % (5);
    uint indexGroup = (index - subIndex) / (5);

    if(indexGroup < ubo.maxIndex)
    {
        bool switchCase = false;
        for(uint i = 0; i < MAXITERATION; i++)
        {
            const vec2[5] CurrentApproximation = switchCase? getApproximationsCase1(indexGroup) : getApproximationsCase0(indexGroup);
            const vec2 z = CurrentApproximation[subIndex];
            const vec2 p = f(z, Coefficients[indexGroup]);

            const vec2 pp = fp(z, Coefficients[indexGroup]);
            const vec2 POverPP = div(p, pp);
            const vec2 sum = sumOfApproximation(subIndex, CurrentApproximation);
            vec2 zPlusOne = z - div(POverPP, vec2(1, 0) - mul(POverPP, sum));

            if(isnan(zPlusOne.x))
                zPlusOne = vec2(cos(subIndex), sin(subIndex));
            
            if(switchCase)
                approximation[indexGroup][subIndex].zw = zPlusOne;
            else
                approximation[indexGroup][subIndex].xy = zPlusOne;

            if(absComplex(z - zPlusOne) < EPSILON)
            {
                approximation[indexGroup][subIndex].xy = zPlusOne;
                break;
            }
            

            switchCase != switchCase;

        }
    }
}

// void main()
// {
//     uint index = gl_GlobalInvocationID.x;

//     if(index < ubo.maxIndex)
//     {
//         for(uint i = 0; i < MAXITERATION; i++)
//         {
//             const vec2[5] CurrentApproximation = approximation[index];
//             for(uint k = 0; k < 5; k++)
//             {
//                 const vec2 z = CurrentApproximation[k];
//                 const vec2 p = f(z, Coefficients[index]);
//                 const vec2 pp = fp(z, Coefficients[index]);

//                 const vec2 POverPP = div(p, pp);
//                 const vec2 sum = sumOfApproximation(k, CurrentApproximation);
//                 const vec2 zPlusOne = z - div(POverPP, vec2(1, 0) - mul(POverPP, sum));
//                 approximation[index][k] = zPlusOne;
//             }
//         }
//     }
// }