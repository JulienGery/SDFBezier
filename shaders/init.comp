#version 450

#define PI 3.14159265358979323846264338327950288419716939937510
#define offset PI / (2.0*5.0)
#define angle 2.0*PI/5.0

layout (binding = 0) uniform ParameterUBO {
    vec2 P_0, p1, p2, p3;
    int maxIndex, width, height, polynomSize, curveIndex;
} ubo;

layout(std140, binding = 1) readonly buffer CoefficientIn
{
    vec2 Coefficients[ ][6];
};

layout(std140, binding = 2) writeonly buffer ParticleSSBOOut {
   vec2 startinPoint[ ][5];
};

vec2 mul(vec2 z, vec2 zp)
{
    vec2 result;
    result.x = z.x * zp.x - z.y * zp.y;
    result.y = z.y * zp.x + z.x * zp.y;
    return result;
}

vec2 div(vec2 z, vec2 zp)
{
    float bottom = zp.x * zp.x + zp.y * zp.y;
    vec2 result = mul(z, vec2(zp.x, -zp.y));

    return result / bottom;
}

float absComplex(vec2 z)
{
    return sqrt(z.x * z.x + z.y * z.y);
}

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

void main()
{
    uint index = gl_GlobalInvocationID.x;
    uint subIndex = index % 5;
    uint IndexGroup = (index - subIndex) / 5;

    if(index < ubo.maxIndex)
    {
        vec2 a_5 = Coefficients[IndexGroup][5];
        vec2 a_0 = Coefficients[IndexGroup][0];
        float radius = pow(absComplex(div(a_0, a_5)), 0.2);

        const vec2 start = radius * vec2(
            cos(subIndex * angle + offset), sin(subIndex * angle + offset));

        startinPoint[IndexGroup][subIndex] = start;
    }
    
}
